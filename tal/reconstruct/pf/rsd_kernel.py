"""
Author      :   Pablo Luesia Lahoz
E-Mail      :   pluesia at unizar.es
File        :   rsd_kernel.py
Description :   Class for a RSD kernel generator, and propagator, in order
                to perform fast propagation from plane to parallel plane
"""

import numpy as np
import os
from numba import njit

class RSD_kernel(object):
    """
    Class implementation for a RSD kernel. It creates a kernel for performance
    fast propagation between paralel planes. 
    """

    def __init__(self, V: np.ndarray, P: np.ndarray, lambda_v: np.ndarray,
                 directory: str = None):
        """
        Initialize the class of the kernel. The plane P and the planes in V has
        to be parallel.
        :param V            : Volume in 3d to propagate, formed by parallel
                              planes. The first axis are the planes, the second
                              are the rows, the third the columns, and the 
                              forth the coordinates of the points in the volume.
        :param P            : Points of the plane origin to propagate. The
                              first axis are the rows, the second the columns,
                              and the third the coordinates of the points in 
                              the plane.
        :param lambda_v     : Arrays of wavelengths to performance the RSD
                              propagation in metters.
        :param directory    : Default value is set to None. String representing
                              the directory of the auxiliary files it may use.
                              Iff the value is None, it will use no file.
                              Existing files generated by previous executions 
                              may be used, if the prefix, V, P and lambda_v 
                              coincide.
        :return             : An instance of RSD_kernel class.
        """
        # Check the planes shapes are the same
        assert P.shape == V[0].shape, "V and P shapes are not the same"
        # Check the planes are parallel
        # First V plane normal
        normal_V, d_V = RSD_kernel.__as_plane_eq(V[0, 0, 0], 
                                                 V[0, -1, 0], 
                                                 V[0, -1, -1])
        normal_P, d_P = RSD_kernel.__as_plane_eq(P[0, 0], P[-1, 0], P[-1, -1])
        # Check if planes are parallel (with an small error to 0)
        assert np.linalg.norm(np.cross(normal_V, normal_P)) == 0, \
                "V and P are not parallel"

        # Volume to propagate
        self._V = V
        self._n_V = normal_V
        self._d_V = d_V
        # Origin plane to propagate
        self._P = P
        self._n_P = normal_P
        self._d_P = d_P
        # Wavelengths to propagate
        self._wl_v = lambda_v
        # Prefix to store and load the files
        self.directory = directory
        self.tag = self.__gen_tag()
        if self.directory is not None:
            self.file_list = self.__matched_files()
        else:
            self.file_list = []
        # Preprocess values. It is None until data is preprocessed
        self._preprocess = None


    __n_file_padding = 6

    ###########################################################################
    #                             PRIVATE METHODS                             #
    ###########################################################################

    # Generate given the data the tag for the file system
    def __gen_tag(self):
        return 'V[' + str(self._V[0,0,0]) + '_' + str(self._V[-1,-1,-1]) + '_'\
                + str(self._V.shape) + ']_P[' + str(self._P[0,0,0]) + '_'\
                + str(self._P.shape) +  ']_lambda[' + str(self._wl_v[0]) + '_'\
                + str(self._wl_v[-1]) + '_' + str(len(self._wl_v)) + ']_'
    

    # Generate given the data the tag for the file system for a RSD kernel
    def __gen_RSD_K_tag(self):
        return "RSD_K_" + self.__gen_tag()


    # Generate given the data the tag for the file system for a RSD kernel
    # in fourier space
    def __gen_f_RSD_K_tag(self):
        return "f_RSD_K_" + self.__gen_tag()


    # Generate a list given the directory indicated in the class for files that
    # match with the parameters indicated. The direcotry cannot be None
    def __matched_files(self):
        if os.path.exists(self.directory):
            list_files = os.listdir(self.directory)
            return [file for file in list_files if self.tag in file]
        else:
            os.mkdir(self.directory)
            return []


    # Given 3 points it return the plane equation
    def __as_plane_eq(p1, p2, p3):
        # Vectors in plane
        v1 = p3 - p1
        v2 = p2 - p1
        # Normal to the plane
        n = np.cross(v1,v2)
        d = np.dot(n, p3)
        return n, d


    # Generate a coordinates matrix kernel for the plane P (at distance 0)
    def __K_at_P(self):
        # Precalculate kernel vectors
        (nx, ny, _) = self._P.shape 
        # Kernel shape
        rx = 2*nx - 1
        ry = 2*ny - 1
        # Delta of the points in i and j axis of the rectangle
        di = self._P[0,1] - self._P[0,0]
        dj = self._P[1,0] - self._P[0,0]
        # Generate the central row, and from it the matrix
        K_row = np.linspace(start= -di * (nx - 1), 
                            stop= di * (nx - 1),
                            num= rx, dtype = np.float64)
        K_base = np.linspace(start = K_row - dj * (ny - 1),
                            stop = K_row + dj * (ny - 1),
                            num= ry, dtype = np.float64)
        return K_base


    # Return an array of vectors from P to the different V planes
    def __vecs_P_to_V_planes(self):
        n_V_m = np.linalg.norm(self._n_V)   # Modulus of V first plane normal
        # Distance from P to V first plane
        d_P2V = np.abs(np.sum(self._n_V * self._P[0, 0]) + self._d_V) / n_V_m
        # Unitary normal vector of V planes
        n_V_i = self._n_V / n_V_m
        # number of V planes
        rz = self._V.shape[0]
        # Distance between V planes
        d_V2V = np.linalg.norm(self._V[0,0,0] - self._V[-1,0,0]) / (rz - 1)
        # Shortest vector from first V plane to the V planes
        n_V2V = np.linspace(start = n_V_i*0,            # Vector to itself
                            stop = n_V_i * d_V2V * rz,  # Vector furthest plane
                            num = rz, dtype = np.float64)
        # Add the vector from P to V
        return n_V2V + n_V_i*d_P2V


    # Given the spatial kernel s_K, it returns the distance kernel.
    def __dist_kernel(s_K: np.ndarray):
        return np.sqrt(np.sum(s_K**2, axis = -1))


    # Performance a convolution in the fourier domain (matrix multiplication).
    def __f_convolution(A: np.ndarray, B: np.ndarray):
        return A*B

    # Return a spatial kernel with the vecotrs from P to the i-th plane in V.
    def __spatial_i_kernel(self, i):
        K_base, v_P2V = self._preprocess
        return K_base + v_P2V[i]

    # Return a RSD kernel in the 2d spatial fourier domain
    def __gen_f_RSD_K_i(self, i):
        s_K = self.__spatial_i_kernel(i)
        d_K = RSD_kernel.__dist_kernel(s_K)
        rsd_K = np.array(list( map(lambda wl: 
                                    RSD_kernel.RSD_kernel_w(d_K, wl),
                                self._wl_v)))
        return np.fft.fft2(rsd_K)

    # Load the if it exists. Otherwise, returns None
    def __load_file(self, file_name: str):
        if file_name in self.file_list:
            return np.load(self.directory + '/' + file_name + '.npy')
        else:
            return None

    # Save the K data, and update the list of files
    def __save_file(self, K, file_name: str):
        np.save(self.directory + '/' + file_name + '.npy', K)
        self.file_list.append(file_name + 'npy')

    ###########################################################################
    #                             PUBLIC METHODS                              #
    ###########################################################################
    def kernel_shape(self):
        """
        Returns the shape of the Kernel
        """
        assert self._preprocess is not None, \
            "pre_proc(self) has to be called before executing!"
        (K_base, _) = self._preprocess
        return (K_base.shape[0], K_base.shape[1])


    def pre_proc(self):
        """
        Prepare the instance of the class to generate the kernel
        """
        self._preprocess = (self.__K_at_P(), self.__vecs_P_to_V_planes())

    
    def propagate_i(self, A: np.ndarray, i: int):
        """
        Propagate from P to the i-th plane in V, the light amplitudes values in
        A, in the fourier domain
        :param A    : Amplitude values in A, which is positioned at the plane
                      P. The space is in domain Fourier, matching with the 
                      wavelengths of the class.
        :param i    : i-th plane to performance the propagation
        :return     : The propagated from P with values H to the i-th plane of 
                      V        
        """
        K_shape = self.kernel_shape()
        f_A = np.fft.fft2(A, s = K_shape)
        f_RSD_K_i = self.get_f_RSD_kernel_i(i)
        f_B = RSD_kernel.__f_convolution(f_A, f_RSD_K_i)
        return np.fft.ifft(f_B)[:, -A.shape[1]:, -A.shape[2]:]


    def f_propagate_i(self, f_A: np.ndarray, i: int):
        """
        Propagate from P to the i-th plane in V, the light amplitudes values in
        f_A, in the fourier domain, where f_A is already in 2d fourier domain
        :param f_A  : Amplitude values in f_A, which is positioned at the plane
                      P. The space is in domain Fourier, matching with the 
                      wavelengths of the class. The data has to be in a 2d
                      fourier space too.
        :param i    : i-th plane to performance the propagation
        :return     : The propagated from P with values H to the i-th plane of 
                      V        
        """
        assert self._preprocess is not None, \
            "pre_proc(self) has to be called before executing!"
        f_RSD_K_i = self.get_f_RSD_kernel_i(i)
        f_B = RSD_kernel.__f_convolution(f_A, f_RSD_K_i)
        return np.fft.ifft2(f_B)


    def get_f_RSD_kernel_i(self, i: int):
        """
        Returns the RSD kernel in the 2d fourier domain of the 
        :param i    : Index of the V plane
        :return     : The plane kernel for i-th plane of V in fourier domain
        """
        if self.directory is not None:
            # Load the data
            file_name = self.__gen_f_RSD_K_tag() \
                        + str(i).zfill(RSD_kernel.__n_file_padding)
            loaded_data = self.__load_file(file_name)
            if loaded_data is not None:
                # Loaded. It returns the data
                return loaded_data
            else:
                # Generate the data
                f_RSD_K_i = self.__gen_f_RSD_K_i(i)
                # Save it and return it
                self.__save_file(f_RSD_K_i, file_name)
                return f_RSD_K_i
        else:
            return self.__gen_f_RSD_K_i(i)
                

    def RSD_kernel_w(K_d: np.ndarray, lambda_w: float):
        """
        Given a rectangular distance spatial kernel K_d, it returns the Rayleigh-
        Sommerfled propagator kernel for the frequency with wavelength lambda_w.
        :param K_d      : Rectangular distance spatial kernel
        :param lambda_w : Wavelength to performance the transformation
        :return         : Complex matrix representing the kernel
        """
        return np.exp(2*np.pi*1j/lambda_w * K_d)/K_d

